# -*- coding: utf-8 -*-
"""LAB_7_1ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1URMrcmzYpZCqnRSLe1FbkTvr8yo5NrGN
"""

import numpy as np

a = np.arange(15).reshape(3, 5)
a

a.shape

a.ndim

a.dtype.name

a.itemsize

a.size

type(a)

b = np.array([6, 7, 8])

b

type(b)

m = np.array([2, 3, 4])
m

m.dtype

n = np.array([1.2, 3.5, 5.1])

n.dtype

o = np.array(1, 2, 3, 4)

o = np.array([1, 2, 3, 4])

b = np.array([(1.5, 2, 3),
 (4, 5, 6)])
b

c = np.array([[1, 2],
 [3, 4]],
             dtype=complex)
c

np.zeros((3, 4))

np.ones((2, 3, 4), dtype=np.int16)

np.empty((2, 3))

np.arange(10, 30, 5)

np.arange(0, 2, 0.3)  # it accepts float arguments

from numpy import pi

np.linspace(0, 2, 9)                   # 0 to 2 samma jane ani 9 ota number line

x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points

f = np.sin(x)

a = np.arange(6)                    # 1d array
print(a)

b = np.arange(12).reshape(4, 3)     # 2d array
print(b)

c = np.arange(24).reshape(2, 3, 4)  # 3d array
print(c)

print(np.arange(10000))

print(np.arange(10000).reshape(100, 100))

a = np.array([20, 30, 40, 50])

b = np.arange(4)

b

c = a - b

c

b**2

10 * np.sin(a)

a < 35

A = np.array([[1, 1],
              [0, 1]])
B = np.array([[2, 0],
              [3, 4]])

A * B     # elementwise product

A @ B     # matrix product

A.dot(B)

rg = np.random.default_rng(1)  # create instance of default random number generator

L = np.ones((2, 3), dtype=int)

J = rg.random((2, 3))

L *= 3

L

J += L

J

L += J

y = np.ones(3, dtype=np.int32)

z = np.linspace(0, pi, 3)

z.dtype.name

w = y + z

w

w.dtype.name

d = np.exp(w * 1j)
d

d.dtype.name

a = rg.random((2, 3))

a

a.sum()

a.min()

a.max()

b = np.arange(12).reshape(3, 4)
b

b.sum(axis=0)     # sum of each column

b.min(axis=1)     # min of each row

b.cumsum(axis=1)  # cumulative sum along each row

B = np.arange(3)

B

np.exp(B)

np.sqrt(B)

C = np.array([2., -1., 4.])

np.add(B, C)

a = np.arange(10)**3
a

a[2]

a[2:5]

a[:6:2] = 1000
a

a[::-1]

for i in a:
    print(i**(1 / 3.))

def f(x, y):
    return 10 * x + y

b = np.fromfunction(f, (5, 4), dtype=int)
b

b[2, 3]

b[0:5, 1]  # each row in the second column of b

b[:, 1]    # equivalent to the previous example

b[1:3, :]  # each column in the second and third row of b

b[-1]   # the last row. Equivalent to b[-1, :]

c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)
               [ 10, 12, 13]],
              [[100, 101, 102],
               [110, 112, 113]]])

c.shape

c[1, ...]  # same as c[1, :, :] or c[1]

c[..., 2]  # same as c[:, :, 2]

for row in b:
    print(row)

for element in b.flat:
    print(element)

a = np.floor(10 * rg.random((3, 4)))
a

a.shape

a.ravel()  # returns the array, flattened

a.reshape(6, 2)  # returns the array with a modified shape

a.T  # returns the array, transposed

a.T.shape

a.shape

a

a.resize((2, 6))
a

a.reshape(3, -1)

a = np.floor(10 * rg.random((2, 2)))

a

b = np.floor(10 * rg.random((2, 2)))
b

np.vstack((a, b))

np.hstack((a, b))

from numpy import newaxis
np.column_stack((a, b))  # with 2D arrays
a = np.array([4., 2.])
b = np.array([3., 8.])

np.column_stack((a, b))  # returns a 2D array

np.hstack((a, b))        # the result is different

a[:, newaxis]  # view `a` as a 2D column vector

np.column_stack((a[:, newaxis], b[:, newaxis]))

np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same

np.r_[1:4, 0, 4]

a = np.floor(10 * rg.random((2, 12)))

a
# Split `a` into 3
np.hsplit(a, 3)

# Split `a` after the third and the fourth column
np.hsplit(a, (3, 4))

a = np.array([[ 0,  1,  2,  3],
              [ 4,  5,  6,  7],
              [ 8,  9, 10, 11]])

b = a            # no new object is created

b is a           # a and b are two names for the same ndarray object

def f(x):
    print(id(x))

id(a)  # id is a unique identifier of an object

f(a)

c = a.view()

c is a

c.base is a            # c is a view of the data owned by a

c.flags.owndata

c = c.reshape((2, 6))  # a's shape doesn't change, reassigned c is still a view of a

a.shape

c[0, 4] = 1234         # a's data changes

a

s = a[:, 1:3]

s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10

a

d = a.copy()  # a new array object with new data is created

d is a

d.base is a  # d doesn't share anything with a

d[0, 0] = 9999

a

e = np.arange(int(1e8))

f = e[:100].copy()

del e  # the memory of ``a`` can be released.

g = np.arange(12)**2  # the first 12 square numbers

i = np.array([1, 1, 3, 8, 5])  # an array of indices

g[i]  # the elements of `a` at the positions `i`

h = np.array([[3, 4], [9, 7]])  # a bidimensional array of indices

g[h]  # the same shape as `j`

palette = np.array([[0, 0, 0],         # black
                    [255, 0, 0],       # red
                    [0, 255, 0],       # green
                    [0, 0, 255],       # blue
                    [255, 255, 255]])  # white

image = np.array([[0, 1, 2, 0],  # each value corresponds to a color in the palette
                  [0, 3, 4, 0]])

palette[image]  # the (2, 4, 3) color image

q = np.arange(12).reshape(3, 4)

q

i = np.array([[0, 1],  # indices for the first dim of `a`
              [1, 2]])
j = np.array([[2, 1],  # indices for the second dim
              [3, 3]])

q[i, j]  # i and j must have equal shape

q[i, 2]

q[:, j]

l = (i, j)

q[l]

s = np.array([i, j])

q[s]

q[tuple(s)]

time = np.linspace(20, 145, 5)  # time scale

data = np.sin(np.arange(20)).reshape(5, 4)  # 4 time-dependent series

time

data

ind = data.argmax(axis=0) # index dinxa of maximum value of the column ( as column is fixed)

ind

# times corresponding to the maxima
time_max = time[ind]

data_max = data[ind, range(data.shape[1])]  # => data[ind[0], 0], data[ind[1], 1]...

time_max

data_max

np.all(data_max == data.max(axis=0))

import numpy as np

a = np.arange(5)
a

a[[0, 0, 2]] = [1, 2, 3]
a

a[[0, 0, 2]] += 1
a

a = np.arange(12).reshape(3, 4)

b = a > 4

b

a[b]

import numpy as np
import matplotlib.pyplot as plt

def mandelbrot(h, w, maxit=20, r=2):
    """Returns an image of the Mandelbrot fractal of size (h,w)."""
    x = np.linspace(-2.5, 1.5, 4*h+1)
    y = np.linspace(-1.5, 1.5, 3*w+1)
    A, B = np.meshgrid(x, y)
    C = A + B*1j
    z = np.zeros_like(C)
    divtime = maxit + np.zeros(z.shape, dtype=int)
    for i in range(maxit):
        z = z**2 + C
        diverge = abs(z) > r                    # who is diverging
        div_now = diverge & (divtime == maxit)  # who is diverging now
        divtime[div_now] = i                    # note when
        z[diverge] = r                          # avoid diverging too much
    return divtime
plt.clf()

plt.imshow(mandelbrot(400, 400))

a = np.arange(12).reshape(3, 4)

b1 = np.array([False, True, True])
b2 = np.array([True, False, True, False])   # first dim selection

a[b1, :]                                   # selecting rows

a[b1]                                      # same thing

a[:, b2]                                   # selecting columns

a[b1, b2]                                  # a weird thing to do

a = np.array([2, 3, 4, 5])

b = np.array([8, 5, 4])

c = np.array([5, 4, 6, 8, 3])

ax, bx, cx = np.ix_(a, b, c)

ax

bx

cx

ax.shape, bx.shape, cx.shape

result = ax + bx * cx

result

result[3, 2, 4]

a[3] + b[2] * c[4]

def ufunc_reduce(ufct, *vectors):
   vs = np.ix_(*vectors)
   r = ufct.identity
   for v in vs:
       r = ufct(r, v)
   return r

ufunc_reduce(np.add, a, b, c)

a = np.arange(30)
b = a.reshape((2, -1, 3))  # -1 means "whatever is needed"

b.shape

b

x = np.arange(0, 10, 2)
y = np.arange(5)

m = np.vstack([x, y])
m

xy = np.hstack([x, y])
xy

import numpy as np
rg = np.random.default_rng(1)
import matplotlib.pyplot as plt
# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2
mu, sigma = 2, 0.5
v = rg.normal(mu, sigma, 10000)
# Plot a normalized histogram with 50 bins
plt.hist(v, bins=50, density=True)       # matplotlib version (plot)
# Compute the histogram with numpy and then plot it
(n, bins) = np.histogram(v, bins=50, density=True)  # NumPy version (no plot)
plt.plot(.5 * (bins[1:] + bins[:-1]), n)

